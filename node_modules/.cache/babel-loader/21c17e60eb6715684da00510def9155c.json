{"remainingRequest":"/home/eric/Workspace/edustreamx/node_modules/thread-loader/dist/cjs.js!/home/eric/Workspace/edustreamx/node_modules/babel-loader/lib/index.js!/home/eric/Workspace/edustreamx/node_modules/eslint-loader/index.js??ref--13-0!/home/eric/Workspace/edustreamx/src/rtc.js","dependencies":[{"path":"/home/eric/Workspace/edustreamx/src/rtc.js","mtime":1554779987870},{"path":"/home/eric/Workspace/edustreamx/node_modules/cache-loader/dist/cjs.js","mtime":1554753029931},{"path":"/home/eric/Workspace/edustreamx/node_modules/thread-loader/dist/cjs.js","mtime":1554753030639},{"path":"/home/eric/Workspace/edustreamx/node_modules/babel-loader/lib/index.js","mtime":1554753029823},{"path":"/home/eric/Workspace/edustreamx/node_modules/eslint-loader/index.js","mtime":1554753030083}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport _Map from \"/home/eric/Workspace/edustreamx/node_modules/@babel/runtime-corejs2/core-js/map\";\nimport _classCallCheck from \"/home/eric/Workspace/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/eric/Workspace/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\n\n/* eslint-disable */\nimport { ClientSocket } from './client-socket.js';\nimport './simplepeer.min.js';\n\nvar RTCNode =\n/*#__PURE__*/\nfunction () {\n  function RTCNode(canvas, vid) {\n    _classCallCheck(this, RTCNode);\n\n    this.canvas = canvas;\n    this.stream = null;\n    this.socket = new ClientSocket(this);\n    this.outgoingRTC = new _Map();\n    this.incomingRTC = null; // single SimplePeer connection \n\n    this.vid = vid;\n    this.tmpBroadcast = false;\n    this.endBroadcast = null;\n    console.log(\"rtc vid = \", vid);\n  }\n\n  _createClass(RTCNode, [{\n    key: \"streamCanvas\",\n    value: function streamCanvas() {\n      if (this.canvas == undefined) throw \"Must supply canvas parameter\";\n      this.canvas.getContext(\"2d\"); // get context once to avoid NS_UNAVAILABLE_ERROR\n\n      this.stream = this.canvas.captureStream();\n    }\n    /** RTCNode.createSourceRTC\n     *    create initiator connection and add to\n     *    map of outgoing connections\n     */\n\n  }, {\n    key: \"createSourceRTC\",\n    value: function createSourceRTC(childID) {\n      var _this = this;\n\n      if (this.stream == undefined) throw \"Cannot create source RTC -- stream undefined\";\n      var rtc = new SimplePeer({\n        initiator: true,\n        stream: this.stream,\n        trickle: false\n      });\n      rtc.on(\"connect\", function () {\n        // handshake completed\n        console.log(\"connected!\");\n      }); // offer signal fires when initiator is instantiated\n      // answer must be signaled to complete handshake\n\n      rtc.on(\"signal\", function (data) {\n        if (data.type == \"offer\") {\n          // send to server so it can forward to connecting client\n          _this.socket.sendMessage({\n            type: \"presentOffer\",\n            offer: data,\n            pid: _this.clientID,\n            cid: childID\n          });\n        }\n      });\n      rtc.on(\"close\", function () {\n        console.log(\"deleting child, broke rtc connection\");\n\n        _this.outgoingRTC.delete(childID);\n\n        _this.endTmpBroadcast();\n      }); // update map\n\n      this.outgoingRTC.set(childID, rtc);\n    }\n  }, {\n    key: \"setTmpBroadcast\",\n    value: function setTmpBroadcast(endBroadcast) {\n      this.tmpBroadcast = true;\n      this.endBroadcast = endBroadcast;\n    }\n  }, {\n    key: \"endTmpBroadcast\",\n    value: function endTmpBroadcast() {\n      if (this.tmpBroadcast) {\n        this.tmpBroadcast = false;\n        this.endBroadcast();\n      }\n    }\n  }, {\n    key: \"createReceiverRTC\",\n    value: function createReceiverRTC(offer) {\n      var _this2 = this;\n\n      if (offer == undefined) throw \"Cannot create receiver RTC node -- offer undefined\";\n      var rtc = new SimplePeer({\n        trickle: false\n      });\n      rtc.on(\"signal\", function (data) {\n        if (data.type == \"answer\") {\n          console.log(\"sending answer\");\n\n          _this2.socket.sendMessage({\n            type: \"presentAnswer\",\n            answer: data,\n            pid: _this2.parentID,\n            cid: _this2.clientID\n          });\n        }\n      }); // fire offer signal to start ICE negotiation\n\n      rtc.signal(offer);\n      rtc.on(\"data\", function (data) {\n        return console.log(\"rtc (data) msg from parent: \", JSON.parse(data));\n      });\n      rtc.on(\"stream\", function (remoteStream) {\n        console.log(\"getting stream\"); // update video src also\n\n        _this2.vid.srcObject = remoteStream;\n\n        _this2.vid.play();\n\n        console.log(\"update vsrc \", _this2.vid.srcObject);\n        _this2.stream = remoteStream; // also add stream to each child if need to propagate new stream\n\n        _this2.outgoingRTC.forEach(function (childRTC) {\n          childRTC.addStream(remoteStream);\n        });\n      });\n      return rtc;\n    }\n  }, {\n    key: \"destroyIncoming\",\n    value: function destroyIncoming() {\n      this.incomingRTC.destroy();\n      this.incomingRTC = null;\n    }\n  }, {\n    key: \"destroyOutgoing\",\n    value: function destroyOutgoing(cid) {\n      var childRTC = this.outgoingRTC.get(cid);\n      if (childRTC == null) throw \"cannot break connection with unknown child\" + cid;\n      childRTC.destroy();\n      this.outgoingRTC.delete(cid);\n    }\n  }, {\n    key: \"clientID\",\n    get: function get() {\n      if (this._clientID == undefined) throw \"Undefined client id\";\n      return this._clientID;\n    },\n    set: function set(id) {\n      this._clientID = id;\n    }\n  }, {\n    key: \"clientId\",\n    get: function get() {\n      throw \"Id typo\";\n    }\n  }]);\n\n  return RTCNode;\n}();\n/*class TeacherNode extends RTCNode {\n  constructor(canvas, vid) {\n    super(vid);\n    if (canvas == undefined) throw \"Must supply canvas parameter\";\n    this.canvas = canvas;\n    this.canvas.getContext(\"2d\");  // get context once to avoid NS_UNAVAILABLE_ERROR\n    this.stream = this.canvas.captureStream();\n  }\n  /** Teacher.createReceiverRTC\n   *    used to allow student to stream to class\n  createReceiverRTC(offer) {\n    this.ogStream = this.stream;\n    return super.createReceiverRTC(offer);\n  }\n\n  destroyIncoming() {}\n}*/\n\n\nexport { //TeacherNode as TeacherNode,\nRTCNode };",{"version":3,"sources":["/home/eric/Workspace/edustreamx/src/rtc.js"],"names":["ClientSocket","RTCNode","canvas","vid","stream","socket","outgoingRTC","incomingRTC","tmpBroadcast","endBroadcast","console","log","undefined","getContext","captureStream","childID","rtc","SimplePeer","initiator","trickle","on","data","type","sendMessage","offer","pid","clientID","cid","delete","endTmpBroadcast","set","answer","parentID","signal","JSON","parse","remoteStream","srcObject","play","forEach","childRTC","addStream","destroy","get","_clientID","id"],"mappings":";;;;;AAAA;AACA,SAASA,YAAT,QAA6B,oBAA7B;AACA,OAAO,qBAAP;;IAEMC,O;;;AACJ,mBAAYC,MAAZ,EAAoBC,GAApB,EAAyB;AAAA;;AACvB,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKE,MAAL,GAAc,IAAd;AACA,SAAKC,MAAL,GAAc,IAAIL,YAAJ,CAAiB,IAAjB,CAAd;AACA,SAAKM,WAAL,GAAmB,UAAnB;AACA,SAAKC,WAAL,GAAmB,IAAnB,CALuB,CAKE;;AACzB,SAAKJ,GAAL,GAAWA,GAAX;AACA,SAAKK,YAAL,GAAoB,KAApB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BR,GAA1B;AACD;;;;mCAac;AACb,UAAI,KAAKD,MAAL,IAAeU,SAAnB,EAA8B,MAAM,8BAAN;AAC9B,WAAKV,MAAL,CAAYW,UAAZ,CAAuB,IAAvB,EAFa,CAEkB;;AAC/B,WAAKT,MAAL,GAAc,KAAKF,MAAL,CAAYY,aAAZ,EAAd;AACD;AAED;;;;;;;oCAIgBC,O,EAAS;AAAA;;AACvB,UAAI,KAAKX,MAAL,IAAeQ,SAAnB,EACE,MAAM,8CAAN;AAEF,UAAII,GAAG,GAAG,IAAIC,UAAJ,CAAe;AACvBC,QAAAA,SAAS,EAAE,IADY;AAEvBd,QAAAA,MAAM,EAAE,KAAKA,MAFU;AAGvBe,QAAAA,OAAO,EAAE;AAHc,OAAf,CAAV;AAKAH,MAAAA,GAAG,CAACI,EAAJ,CAAO,SAAP,EAAkB,YAAM;AACtB;AACAV,QAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACD,OAHD,EATuB,CAcvB;AACA;;AACAK,MAAAA,GAAG,CAACI,EAAJ,CAAO,QAAP,EAAiB,UAAAC,IAAI,EAAI;AACvB,YAAIA,IAAI,CAACC,IAAL,IAAa,OAAjB,EAA0B;AACxB;AACA,UAAA,KAAI,CAACjB,MAAL,CAAYkB,WAAZ,CAAwB;AACtBD,YAAAA,IAAI,EAAE,cADgB;AAEtBE,YAAAA,KAAK,EAAEH,IAFe;AAGtBI,YAAAA,GAAG,EAAE,KAAI,CAACC,QAHY;AAItBC,YAAAA,GAAG,EAAEZ;AAJiB,WAAxB;AAMD;AACF,OAVD;AAYAC,MAAAA,GAAG,CAACI,EAAJ,CAAO,OAAP,EAAgB,YAAM;AACpBV,QAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ;;AACA,QAAA,KAAI,CAACL,WAAL,CAAiBsB,MAAjB,CAAwBb,OAAxB;;AACA,QAAA,KAAI,CAACc,eAAL;AACD,OAJD,EA5BuB,CAiCvB;;AACA,WAAKvB,WAAL,CAAiBwB,GAAjB,CAAqBf,OAArB,EAA8BC,GAA9B;AACD;;;oCAEeP,Y,EAAc;AAC5B,WAAKD,YAAL,GAAoB,IAApB;AACA,WAAKC,YAAL,GAAoBA,YAApB;AACD;;;sCAEiB;AAChB,UAAI,KAAKD,YAAT,EAAuB;AACrB,aAAKA,YAAL,GAAoB,KAApB;AACA,aAAKC,YAAL;AACD;AACF;;;sCAEiBe,K,EAAO;AAAA;;AACvB,UAAIA,KAAK,IAAIZ,SAAb,EACE,MAAM,oDAAN;AACF,UAAII,GAAG,GAAG,IAAIC,UAAJ,CAAe;AAAEE,QAAAA,OAAO,EAAG;AAAZ,OAAf,CAAV;AAEAH,MAAAA,GAAG,CAACI,EAAJ,CAAO,QAAP,EAAiB,UAAAC,IAAI,EAAI;AACvB,YAAIA,IAAI,CAACC,IAAL,IAAa,QAAjB,EAA2B;AACzBZ,UAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;;AACA,UAAA,MAAI,CAACN,MAAL,CAAYkB,WAAZ,CAAwB;AACtBD,YAAAA,IAAI,EAAE,eADgB;AAEtBS,YAAAA,MAAM,EAAEV,IAFc;AAGtBI,YAAAA,GAAG,EAAE,MAAI,CAACO,QAHY;AAItBL,YAAAA,GAAG,EAAE,MAAI,CAACD;AAJY,WAAxB;AAMD;AACF,OAVD,EALuB,CAiBvB;;AACAV,MAAAA,GAAG,CAACiB,MAAJ,CAAWT,KAAX;AAEAR,MAAAA,GAAG,CAACI,EAAJ,CAAO,MAAP,EAAe,UAAAC,IAAI;AAAA,eAAIX,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA6CuB,IAAI,CAACC,KAAL,CAAWd,IAAX,CAA7C,CAAJ;AAAA,OAAnB;AAEAL,MAAAA,GAAG,CAACI,EAAJ,CAAO,QAAP,EAAiB,UAAAgB,YAAY,EAAI;AAC/B1B,QAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAD+B,CAE/B;;AACA,QAAA,MAAI,CAACR,GAAL,CAASkC,SAAT,GAAqBD,YAArB;;AACA,QAAA,MAAI,CAACjC,GAAL,CAASmC,IAAT;;AACA5B,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ,EAA4B,MAAI,CAACR,GAAL,CAASkC,SAArC;AACA,QAAA,MAAI,CAACjC,MAAL,GAAcgC,YAAd,CAN+B,CAO/B;;AACA,QAAA,MAAI,CAAC9B,WAAL,CAAiBiC,OAAjB,CAAyB,UAAAC,QAAQ,EAAI;AACnCA,UAAAA,QAAQ,CAACC,SAAT,CAAmBL,YAAnB;AACD,SAFD;AAGD,OAXD;AAYA,aAAOpB,GAAP;AACD;;;sCAEiB;AAChB,WAAKT,WAAL,CAAiBmC,OAAjB;AACA,WAAKnC,WAAL,GAAmB,IAAnB;AACD;;;oCAEeoB,G,EAAK;AACnB,UAAIa,QAAQ,GAAG,KAAKlC,WAAL,CAAiBqC,GAAjB,CAAqBhB,GAArB,CAAf;AACA,UAAIa,QAAQ,IAAI,IAAhB,EAAsB,MAAM,+CAA+Cb,GAArD;AACtBa,MAAAA,QAAQ,CAACE,OAAT;AACA,WAAKpC,WAAL,CAAiBsB,MAAjB,CAAwBD,GAAxB;AACD;;;wBArHc;AACb,UAAI,KAAKiB,SAAL,IAAkBhC,SAAtB,EAAiC,MAAM,qBAAN;AACjC,aAAO,KAAKgC,SAAZ;AACD,K;sBAIYC,E,EAAI;AACf,WAAKD,SAAL,GAAiBC,EAAjB;AACD;;;wBAJc;AAAE,YAAM,SAAN;AAAkB;;;;;AAmHrC;;;;;;;;;;;;;;;;;;;AAkBA,SACE;AACA5C,OAFF","sourcesContent":["/* eslint-disable */\nimport { ClientSocket } from './client-socket.js'\nimport './simplepeer.min.js'\n\nclass RTCNode {\n  constructor(canvas, vid) {\n    this.canvas = canvas;\n    this.stream = null;\n    this.socket = new ClientSocket(this);\n    this.outgoingRTC = new Map(); \n    this.incomingRTC = null; // single SimplePeer connection \n    this.vid = vid;\n    this.tmpBroadcast = false;\n    this.endBroadcast = null;\n    console.log(\"rtc vid = \", vid);\n  }\n\n  get clientID() {\n    if (this._clientID == undefined) throw \"Undefined client id\";\n    return this._clientID;\n  }\n\n  get clientId() { throw \"Id typo\"; }\n\n  set clientID(id) {\n    this._clientID = id;\n  }\n\n  streamCanvas() {\n    if (this.canvas == undefined) throw \"Must supply canvas parameter\";\n    this.canvas.getContext(\"2d\");  // get context once to avoid NS_UNAVAILABLE_ERROR\n    this.stream = this.canvas.captureStream();\n  }\n\n  /** RTCNode.createSourceRTC\n   *    create initiator connection and add to\n   *    map of outgoing connections\n   */\n  createSourceRTC(childID) {\n    if (this.stream == undefined) \n      throw \"Cannot create source RTC -- stream undefined\";\n\n    var rtc = new SimplePeer({\n      initiator: true,\n      stream: this.stream,\n      trickle: false,\n    });\n    rtc.on(\"connect\", () => {\n      // handshake completed\n      console.log(\"connected!\");\n    });\n\n    // offer signal fires when initiator is instantiated\n    // answer must be signaled to complete handshake\n    rtc.on(\"signal\", data => {\n      if (data.type == \"offer\") {\n        // send to server so it can forward to connecting client\n        this.socket.sendMessage({\n          type: \"presentOffer\",\n          offer: data,\n          pid: this.clientID,\n          cid: childID,\n        });\n      }\n    });\n\n    rtc.on(\"close\", () => {\n      console.log(\"deleting child, broke rtc connection\")\n      this.outgoingRTC.delete(childID)\n      this.endTmpBroadcast();\n    })\n    // update map\n    this.outgoingRTC.set(childID, rtc);\n  }\n\n  setTmpBroadcast(endBroadcast) {\n    this.tmpBroadcast = true\n    this.endBroadcast = endBroadcast\n  }\n\n  endTmpBroadcast() {\n    if (this.tmpBroadcast) {\n      this.tmpBroadcast = false\n      this.endBroadcast()\n    }\n  }\n\n  createReceiverRTC(offer) {\n    if (offer == undefined) \n      throw \"Cannot create receiver RTC node -- offer undefined\";\n    var rtc = new SimplePeer({ trickle : false});\n\n    rtc.on(\"signal\", data => {\n      if (data.type == \"answer\") {\n        console.log(\"sending answer\");\n        this.socket.sendMessage({ \n          type: \"presentAnswer\",\n          answer: data,\n          pid: this.parentID,\n          cid: this.clientID,\n        });\n      }\n    });\n\n    // fire offer signal to start ICE negotiation\n    rtc.signal(offer);\n\n    rtc.on(\"data\", data => console.log(\"rtc (data) msg from parent: \" , JSON.parse(data)));\n\n    rtc.on(\"stream\", remoteStream => {\n      console.log(\"getting stream\");\n      // update video src also\n      this.vid.srcObject = remoteStream;\n      this.vid.play();\n      console.log(\"update vsrc \", this.vid.srcObject);\n      this.stream = remoteStream; \n      // also add stream to each child if need to propagate new stream\n      this.outgoingRTC.forEach(childRTC => {\n        childRTC.addStream(remoteStream);\n      });\n    });\n    return rtc;\n  }\n\n  destroyIncoming() {\n    this.incomingRTC.destroy();\n    this.incomingRTC = null\n  }\n\n  destroyOutgoing(cid) {\n    var childRTC = this.outgoingRTC.get(cid);\n    if (childRTC == null) throw \"cannot break connection with unknown child\" + cid;\n    childRTC.destroy();\n    this.outgoingRTC.delete(cid);\n  }\n}\n\n/*class TeacherNode extends RTCNode {\n  constructor(canvas, vid) {\n    super(vid);\n    if (canvas == undefined) throw \"Must supply canvas parameter\";\n    this.canvas = canvas;\n    this.canvas.getContext(\"2d\");  // get context once to avoid NS_UNAVAILABLE_ERROR\n    this.stream = this.canvas.captureStream();\n  }\n  /** Teacher.createReceiverRTC\n   *    used to allow student to stream to class\n  createReceiverRTC(offer) {\n    this.ogStream = this.stream;\n    return super.createReceiverRTC(offer);\n  }\n\n  destroyIncoming() {}\n}*/\n\nexport {\n  //TeacherNode as TeacherNode,\n  RTCNode as RTCNode,\n};"]}]}