{"remainingRequest":"/home/daniel/edustreamx/node_modules/thread-loader/dist/cjs.js!/home/daniel/edustreamx/node_modules/babel-loader/lib/index.js!/home/daniel/edustreamx/node_modules/eslint-loader/index.js??ref--13-0!/home/daniel/edustreamx/src/rtc.js","dependencies":[{"path":"/home/daniel/edustreamx/src/rtc.js","mtime":1554568208663},{"path":"/home/daniel/edustreamx/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/daniel/edustreamx/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/daniel/edustreamx/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/daniel/edustreamx/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _possibleConstructorReturn from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _get from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/get\";\nimport _inherits from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _Map from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/core-js/map\";\nimport _classCallCheck from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/edustreamx/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\n\n/* eslint-disable */\nimport { ClientSocket } from './client-socket.js';\nimport './simplepeer.min.js';\n\nvar RTCNode =\n/*#__PURE__*/\nfunction () {\n  function RTCNode(vid) {\n    _classCallCheck(this, RTCNode);\n\n    this.stream = null;\n    this.socket = new ClientSocket(this);\n    this.outgoingRTC = new _Map();\n    this.incomingRTC = null; // single SimplePeer connection \n\n    this.vid = vid;\n    console.log(\"rtc vid = \", vid);\n  }\n\n  _createClass(RTCNode, [{\n    key: \"createSourceRTC\",\n\n    /** RTCNode.createSourceRTC\n     *    create initiator connection and add to\n     *    map of outgoing connections\n     */\n    value: function createSourceRTC(childID) {\n      var _this = this;\n\n      if (this.stream == undefined) throw \"Cannot create source RTC -- stream undefined\";\n      var rtc = new SimplePeer({\n        initiator: true,\n        stream: this.stream,\n        trickle: false\n      });\n      rtc.on(\"connect\", function () {\n        // handshake completed\n        console.log(\"connected!\");\n      }); // offer signal fires when initiator is instantiated\n      // answer must be signaled to complete handshake\n\n      rtc.on(\"signal\", function (data) {\n        if (data.type == \"offer\") {\n          // send to server so it can forward to connecting client\n          _this.socket.sendMessage({\n            type: \"presentOffer\",\n            offer: data,\n            pid: _this.clientID,\n            cid: childID\n          });\n        }\n      }); // update map\n\n      this.outgoingRTC.set(childID, rtc);\n    }\n  }, {\n    key: \"createReceiverRTC\",\n    value: function createReceiverRTC(offer) {\n      var _this2 = this;\n\n      if (offer == undefined) throw \"Cannot create receiver RTC node -- offer undefined\";\n      var rtc = new SimplePeer({\n        trickle: false\n      });\n      rtc.on(\"signal\", function (data) {\n        if (data.type == \"answer\") {\n          console.log(\"sending answer\");\n\n          _this2.socket.sendMessage({\n            type: \"presentAnswer\",\n            answer: data,\n            pid: _this2.parentID,\n            cid: _this2.clientID\n          });\n        }\n      }); // fire offer signal to start ICE negotiation\n\n      rtc.signal(offer);\n      rtc.on(\"data\", function (data) {\n        return console.log(\"rtc (data) msg from parent: \", JSON.parse(data));\n      });\n      rtc.on(\"stream\", function (remoteStream) {\n        console.log(\"getting stream\"); // update video src also\n\n        _this2.vid.srcObject = remoteStream;\n\n        _this2.vid.play();\n\n        console.log(\"update vsrc \", _this2.vid.srcObject);\n        _this2.stream = remoteStream; // also add stream to each child if need to propagate new stream\n\n        _this2.outgoingRTC.forEach(function (childRTC) {\n          childRTC.addStream(remoteStream);\n        });\n      });\n      return rtc;\n    }\n  }, {\n    key: \"destroyIncoming\",\n    value: function destroyIncoming() {\n      this.incomingRTC.destroy();\n    }\n  }, {\n    key: \"destroyOutgoing\",\n    value: function destroyOutgoing(cid) {\n      var childRTC = this.outgoingRTC.get(cid);\n      if (childRTC == null) throw \"cannot break connection with unknown child\" + cid;\n      childRTC.destroy();\n      this.outgoingRTC.delete(cid);\n    }\n  }, {\n    key: \"clientID\",\n    get: function get() {\n      if (this._clientID == undefined) throw \"Undefined client id\";\n      return this._clientID;\n    },\n    set: function set(id) {\n      this._clientID = id;\n    }\n  }, {\n    key: \"clientId\",\n    get: function get() {\n      throw \"Id typo\";\n    }\n  }]);\n\n  return RTCNode;\n}();\n\nvar TeacherNode =\n/*#__PURE__*/\nfunction (_RTCNode) {\n  _inherits(TeacherNode, _RTCNode);\n\n  function TeacherNode(canvas, vid) {\n    var _this3;\n\n    _classCallCheck(this, TeacherNode);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TeacherNode).call(this, vid));\n    if (canvas == undefined) throw \"Must supply canvas parameter\";\n    _this3.canvas = canvas;\n\n    _this3.canvas.getContext(\"2d\"); // get context once to avoid NS_UNAVAILABLE_ERROR\n\n\n    _this3.stream = _this3.canvas.captureStream();\n    return _this3;\n  }\n  /** Teacher.createReceiverRTC\n   *    used to allow student to stream to class\n   */\n\n\n  _createClass(TeacherNode, [{\n    key: \"createReceiverRTC\",\n    value: function createReceiverRTC(offer) {\n      this.ogStream = this.stream;\n      return _get(_getPrototypeOf(TeacherNode.prototype), \"createReceiverRTC\", this).call(this, offer);\n    }\n  }, {\n    key: \"destroyIncoming\",\n    value: function destroyIncoming() {}\n  }]);\n\n  return TeacherNode;\n}(RTCNode);\n\nexport { TeacherNode, RTCNode };",{"version":3,"sources":["/home/daniel/edustreamx/src/rtc.js"],"names":["ClientSocket","RTCNode","vid","stream","socket","outgoingRTC","incomingRTC","console","log","childID","undefined","rtc","SimplePeer","initiator","trickle","on","data","type","sendMessage","offer","pid","clientID","cid","set","answer","parentID","signal","JSON","parse","remoteStream","srcObject","play","forEach","childRTC","addStream","destroy","get","delete","_clientID","id","TeacherNode","canvas","getContext","captureStream","ogStream"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport { ClientSocket } from './client-socket.js'\nimport './simplepeer.min.js'\n\nclass RTCNode {\n  constructor(vid) {\n    this.stream = null;\n    this.socket = new ClientSocket(this);\n    this.outgoingRTC = new Map(); \n    this.incomingRTC = null; // single SimplePeer connection \n    this.vid = vid;\n    console.log(\"rtc vid = \", vid);\n  }\n\n  get clientID() {\n    if (this._clientID == undefined) throw \"Undefined client id\";\n    return this._clientID;\n  }\n\n  get clientId() { throw \"Id typo\"; }\n\n  set clientID(id) {\n    this._clientID = id;\n  }\n\n  /** RTCNode.createSourceRTC\n   *    create initiator connection and add to\n   *    map of outgoing connections\n   */\n  createSourceRTC(childID) {\n    if (this.stream == undefined) \n      throw \"Cannot create source RTC -- stream undefined\";\n\n    var rtc = new SimplePeer({\n      initiator: true,\n      stream: this.stream,\n      trickle: false,\n    });\n    rtc.on(\"connect\", () => {\n      // handshake completed\n      console.log(\"connected!\");\n    });\n\n    // offer signal fires when initiator is instantiated\n    // answer must be signaled to complete handshake\n    rtc.on(\"signal\", data => {\n      if (data.type == \"offer\") {\n        // send to server so it can forward to connecting client\n        this.socket.sendMessage({\n          type: \"presentOffer\",\n          offer: data,\n          pid: this.clientID,\n          cid: childID,\n        });\n      }\n    });\n    \n    // update map\n    this.outgoingRTC.set(childID, rtc);\n  }\n\n  createReceiverRTC(offer) {\n    if (offer == undefined) \n      throw \"Cannot create receiver RTC node -- offer undefined\";\n    var rtc = new SimplePeer({ trickle : false});\n\n    rtc.on(\"signal\", data => {\n      if (data.type == \"answer\") {\n        console.log(\"sending answer\");\n        this.socket.sendMessage({ \n          type: \"presentAnswer\",\n          answer: data,\n          pid: this.parentID,\n          cid: this.clientID,\n        });\n      }\n    });\n\n    // fire offer signal to start ICE negotiation\n    rtc.signal(offer);\n\n    rtc.on(\"data\", data => console.log(\"rtc (data) msg from parent: \" , JSON.parse(data)));\n\n    rtc.on(\"stream\", remoteStream => {\n      console.log(\"getting stream\");\n      // update video src also\n      this.vid.srcObject = remoteStream;\n      this.vid.play();\n      console.log(\"update vsrc \", this.vid.srcObject);\n      this.stream = remoteStream; \n      // also add stream to each child if need to propagate new stream\n      this.outgoingRTC.forEach(childRTC => {\n        childRTC.addStream(remoteStream);\n      });\n    });\n    return rtc;\n  }\n\n  destroyIncoming() {\n    this.incomingRTC.destroy();\n  }\n\n  destroyOutgoing(cid) {\n    var childRTC = this.outgoingRTC.get(cid);\n    if (childRTC == null) throw \"cannot break connection with unknown child\" + cid;\n    childRTC.destroy();\n    this.outgoingRTC.delete(cid);\n  }\n}\n\nclass TeacherNode extends RTCNode {\n  constructor(canvas, vid) {\n    super(vid);\n    if (canvas == undefined) throw \"Must supply canvas parameter\";\n    this.canvas = canvas;\n    this.canvas.getContext(\"2d\");  // get context once to avoid NS_UNAVAILABLE_ERROR\n    this.stream = this.canvas.captureStream();\n  }\n  /** Teacher.createReceiverRTC\n   *    used to allow student to stream to class\n   */ \n  createReceiverRTC(offer) {\n    this.ogStream = this.stream;\n    return super.createReceiverRTC(offer);\n  }\n\n  destroyIncoming() {}\n}\n\nexport {\n  TeacherNode as TeacherNode,\n  RTCNode as RTCNode,\n};"]}]}